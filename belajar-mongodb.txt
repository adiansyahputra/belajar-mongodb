--Pengenalan MongoDB
Pengenalan MongoDB
MongoDB merupakan free dan opensource database management system
MongoDB merupakan database management system berbasis document 
Dikembangkan oleh perusahaan bernama 10gen tahun 2007
Dirilis ke public tahun 2009
Saat ini perusahaan 10gen sudah berganti nama menjadi MongoDB Inc
MongoDB hampir mendukung semua bahasa pemrograman sebagai client nya
MongoDB tidak menggunakan SQL, namun menggunakan JavaScript sebagai bahasa utama untuk manipulasi document
https://github.com/mongodb/mongo 

db-engines.com/en/ranking/document+store

Apa itu Document Oriented Database

Istilah Relational DB vs Document DB
 Relational DB
Document DB (MongoDB)
Database
Database
Table
Collection
Column
Field
Row, Record
Document (JSON, XML, dan lain-lain)
Join Table
Embedded Document, Reference
SQL
JavaScript (MongoDB)

--Menginstall MongoDB
Menginstall MongoDB
Linux : https://docs.mongodb.com/manual/administration/install-on-linux/
Mac : https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/
Windows : https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/

Menginstall MongoDB Menggunakan Docker
MongoDB Docker Image : https://hub.docker.com/_/mongo
Docker Compose : https://github.com/ProgrammerZamanNow/belajar-mongodb/blob/master/mongodb/docker-compose.yml

--MongoDB Client
Mongo Shell
MongoDB menyediakan aplikasi mongo client berupa command line interface untuk terkoneksi ke MongoDB Server dengan nama mongo shell.
Mongo shell sangat bermanfaat saat kita tidak harus konek ke mongo server tanpa GUI
Mongo shell menggunakan bahasa pemrograman JavaScript

Menggunakan Mongo Shell
mongo --host localhost --port 27017

MongoDB GUI Client
Jika kita terbiasa menggunakan GUI, ada beberapa aplikasi yang bisa kita gunakan sebagai mongo client, seperti :
MongoDB Compass : https://www.mongodb.com/products/compass
JetBrains DataGrip : https://www.jetbrains.com/datagrip/
MongoDB for Visual Studio Code : https://marketplace.visualstudio.com/items?itemName=mongodb.mongodb-vscode
Robo 3T : https://robomongo.org/

masuk ke container mongo 
docker exec -it mongo /bin/sh  
mongo

--Database
Database
Database adalah tempat menyimpan collection 
Semua collection harus disimpan di database
Biasanya database digunakan untuk memisahkan data secara logical per aplikasi, artinya biasanya satu aplikasi akan memiliki satu database
Jarang sekali kita akan menggunakan satu database untuk beberapa aplikasi

Membuat Database
Kita tidak perlu secara eksplisit membuat database
MongoDB akan secara otomatis membuatkan database sesuai dengan nama database yang kita pilih
Untuk memilih nama database, kita bisa menggunakan perintah “use” diikuti nama database

Memilih Database
> use belajar
> show databases

Database Methods
 Database Methods
Keterangan
db.dropDatabase()
Menghapus database
db.getName()
Mengambil nama database
db.hostInfo()
Mengambil informasi host tempat mongodb
db.version()
Mengambil versi database
db.stats()
Mengambil statistik penggunaan database

--Collection
Collection
Collection adalah tempat menyimpan document
Maximum per document yang bisa disimpan adalah 16MB
Maximum level nested document yang bisa disimpan adalah 100 level 

Database Methods untuk Collection
 Database Methods untuk Collection
Keterangan
db.getCollectionNames()
Mengambil semua nama collection
db.createCollection(name)
Membuat collection baru
db.getCollection(name)
Mendapatkan object collection
db.<name>
Sama dengan db.getCollection(<name>)
db.getCollectionInfos()
Mendapat informasi semua collection

Collection Methods
 Database Methods untuk Collection
Keterangan
db.<collection>.find()
Mengambil semua document 
db.<collection>.count()
Mengambil jumlah document
db.<collection>.drop()
Menghapus collection
db.<collection>.totalSize()
Mengambil total ukuran collection
db.<collection>.stats()
Mengambil informasi statistik collection

Kode Program : Collection
https://github.com/ProgrammerZamanNow/belajar-mongodb/blob/master/scripts/collection.js
// Membuat Collection customers
db.createCollection('customers');

// Membuat Collection products
db.createCollection('products');

// Membuat Collection orders
db.createCollection('orders');

--Data Model
Kenapa Perlu Mengerti Data Modeling
Pindah dari relational database ke document database bukanlah hal yang sesederhana hanya dengan memindahkan semua table ke collection
Penggunaan document database tidak akan mendatangkan manfaat besar jika kita tidak mengerti cara memodelkan data untuk kebutuhan aplikasi kita
Saat memodelkan data menggunakan relational database, biasanya kita mengacu ke database normalization 
Saat memodelkan data menggunakan document database, kita harus mengacu ke penggunaan aplikasi dalam melakukan query, update dan memproses data

Schema yang Flexible
Tidak seperti di relational database, di MongoDB kita bisa memasukkan data ke collection secara langsung tanpa mendefinisikan schema collection nya.
Schema untuk collection di MongoDB sangat flexible, tiap document bisa berbeda. Tidak seperti table di relational database yang harus sama  tiap record.
Namun pada prakteknya, sangat direkomendasikan menggunakan jenis data yang sama untuk tiap collection, walaupun bisa berbeda-beda di collection yang sama

Primary Key
Saat membuat dokumen di MongoDB, kita wajib menambahkan primary key
Tidak seperti relational database yang bebas membuat column untuk primary key, di MongoDB, primary key wajib menggunakan field _id
Selain itu primary key tidak bisa lebih dari 1 field, hanya bisa field _id, jadi jika kita ingin membuat composite primary key, maka kita hanya bisa melakukan dengan menggunakan 1 field _id

Struktur Dokumen - Embedded

Struktur Dokumen - Reference

Embedded vs Reference
Gunakan Embedded jika :
Antar document saling ketergantungan
Tidak bisa langsung melakukan perubahan ke embedded document
Embedded document selalu dibutuhkan ketika mengambil data document

Gunakan Reference jika :
Antar document bisa berdiri sendiri dan tidak terlalu ketergantungan satu sama lain
Bisa melakukan manipulasi data langsung terhadap reference document
Reference document tidak selalu dibutuhkan saat mengambil document

--BSON
BSON
BSON singkatan dari Binary JSON, yaitu binary-encoded serialization dokumen seperti JSON
Sama seperti JSON, di BSON juga bisa kita bisa menggunakan embedded object, array dan lain-lain
http://bsonspec.org/ 
https://docs.mongodb.com/manual/reference/bson-types/ 

Tipe Data di BSON (1)
 Tipe Data
Alias
Double
double
String
string
Object
object
Array
arrat
Binary Data
binData
ObjectId
objectId

Tipe Data di BSON (2)
 Tipe Data
Alias
Boolean
bool
Date
date
Null
null
Regular Expression
regex
JavaScript
javascript
JavaScript with Scope
javascriptWithScope

Tipe Data di BSON (3)
 Tipe Data
Alias
32 Bit Integer
int
Timestamp
timestamp
64 Bit Integer
long
Decimal 128
decimal
Min Key
minKey
Max key
maxKey

ObjectId
ObjectId adalah random data yang unik, cepat untuk digenerate dan terurut.
Nilai ObjectId memiliki ukuran panjang 12 byte, konsisten terdiri dari informasi 4 byte timestamp, 5 byte random value, dan 3 byte incrementing counter
ObjectId digunakan sebagai sebagai default _id (primary key) di document jika kita tidak secara eksplisit menyebutkan _id document nya

Date dan ISODate
BSON Date adalah 64 bit integer yang merepresentasikan angka milisecond sejak Unix epoch (1 Januari 1970).
Nilai ini bisa merepresentasikan waktu dengan jarak 290 juta tahun sebelum dan setelah unix epoch.
ISODate merupakan representasi waktu yang digunakan oleh MongoDB
Date ini kompatibel dengan Date di JavaScript
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date 

--Insert Document
Insert Document
Untuk menyimpan data ke MongoDB, kita perlu membuat document dalam bentuk JSON
Field _id tidak wajib dimasukkan, jika kita tidak memasukkan field _id, maka secara otomatis MongoDB akan membuat _id baru secara random dengan tipe data ObjectId
Atau kita juga bisa secara eksplisit membuat ObjectId baru dengan menggunakan perintah “new ObjectId()”

Insert Document Function
 Function
Keterangan
db.<collection>.insertOne(document)
Menambah dokumen ke collection
db.<collection>.insertMany(array<document>)
Menambah semua dokumen di array ke collection 
db.<collection>.insert(document / array)
Menambah satu document atau banyak dokumen

Kode Program
https://github.com/ProgrammerZamanNow/belajar-mongodb/blob/master/scripts/insert.js
// Insert document customers
db.customers.insertOne({
    _id: "khannedy",
    name: "Eko Kurniawan Khannedy"
});

// Insert document products
db.products.insertMany([
    {
        _id: 1,
        name: "Indomie Ayam Bawang",
        price: new NumberLong(2000)
    },
    {
        _id: 2,
        name: "Mie Sedap",
        price: new NumberLong(2000)
    }
]);

// Insert document orders
db.orders.insertOne({
    _id: new ObjectId(),
    total: new NumberLong(8000),
    items: [
        {
            product_id: 1,
            price: new NumberLong(2000),
            quantity: new NumberInt(2)
        },
        {
            product_id: 2,
            price: new NumberLong(2000),
            quantity: new NumberInt(2)
        }
    ]
})

--Query Document
Query Document
Sama seperti di relational database, di MongoDB pun kita bisa melakukan query atau pencarian document yang sudah kita simpan di collection

Query Document Function
 Function
Keterangan
db.<collection>.find(query)
Mencari document dengan query

Kode Program
https://github.com/ProgrammerZamanNow/belajar-mongodb/blob/master/scripts/query.js
// select *  from customers where _id = 'khannedy'
db.customers.find({
    _id: "khannedy"
});

// select * from customers where name = 'Eko Kurniawan Khannedy'
db.customers.find({
    name: "Eko Kurniawan Khannedy"
});

// select * from products where price = 2000
db.products.find({
    price: 2000
});

// select * from orders where items.product_id = 1
db.orders.find({
    "items.product_id": 1
});

--Comparison Query Operator
Comparison Operator (1)
 Operator
Keterangan
$eq
Membandingkan value dengan value lain
$gt
Membandingkan value lebih besar dari value lain
$gte
Membandingkan value lebih besar atau sama dengan value lain
$lt
Membandingkan value lebih kecil dari value lain
$lte
Membandingkan value lebih kecil atau sama dengan value lain

Comparison Operator (2)
 Operator
Keterangan
$in
Membandingkan value dengan value yang ada di array
$nin
Membandingkan value tidak ada dalam value yang ada di array
$ne
Membandingkan value tidak sama dengan value lain

Syntax Comparison Operator

Kode Program
https://github.com/ProgrammerZamanNow/belajar-mongodb/blob/master/scripts/query-comparison.js
// select * from customers where _id = 'khannedy'
db.customers.find({
    _id: {
        $eq: "khannedy"
    }
});

// select * from products where price > 1000
db.products.find({
    price: {
        $gt: 1000
    }
});

// insert product documents
db.products.insertMany([
    {
        _id: 3,
        name: "Pop Mie Rasa Bakso",
        price: new NumberLong(2500),
        category: "food"
    },
    {
        _id: 4,
        name: "Samsung Galaxy S9+",
        price: new NumberLong(10000000),
        category: "handphone"
    },
    {
        _id: 5,
        name: "Acer Precator XXI",
        price: new NumberLong(25000000),
        category: "laptop"
    }
]);

// select * from products where category in ('handphone', 'laptop') and price > 5000000
db.products.find({
    category: {
        $in: ["handphone", "laptop"]
    },
    price: {
        $gt: 5000000
    }
});

--Logical Query Operator
Logical Operator
 Operator
Keterangan
$and
Menggabungkan query dengan operasi AND, mengembalikan document jika semua kondisi benar
$or
Menggabungkan query dengan operasi OR, mengembalikan document jika salah satu kondisi benar
$nor
Menggabungkan query dengan operasi NOR, mengembalikan document yang gagal di semua kondisi
$not
Membalikkan kondisi, mengembalikan document yang tidak sesuai kondisi

Kode Program
https://github.com/ProgrammerZamanNow/belajar-mongodb/blob/master/scripts/query-logical.js
// select * from products where category in ('laptop', 'handphone') and price > 20000000
db.products.find({
    $and: [
        {
            category: {
                $in: ["laptop", "handphone"]
            }
        },
        {
            price: {
                $gt: 20000000
            }
        }
    ]
});

// select * from products where category not in ('laptop', 'handphone')
db.products.find({
    category: {
        $not: {
            $in: ["laptop", "handphone"]
        }
    }
});

// select * from products where price between 10000000 and 20000000 and category != 'food'
db.products.find({
    $and: [
        {
            price: {
                $gte: 10000000,
                $lte: 20000000
            }
        },
        {
            category: {
                $ne: 'food'
            }
        }
    ]
});

--Element Query Operator
Element Operator
 Operator
Keterangan
$exists
Mencocokkan document yang memiliki field tersebut
$type
Mencocokkan document yang memiliki type field tersebut

Kode Program
https://github.com/ProgrammerZamanNow/belajar-mongodb/blob/master/scripts/query-element.js
// select * from products where category is null
db.products.find({
    category: {
        $exists: false
    }
});

// select * from products where type(category) = "string"
db.products.find({
    category: {
        $type: "string"
    }
});

// select * from products where type(price) in ("int", "long")
db.products.find({
    price: {
        $type: ["int", "long"]
    }
});

--Evaluation Query Operator
Evaluation Operator
 Operator
Keterangan
$expr
Menggunakan aggregation operation
$jsonSchema
Validasi document sesuai dengan JSON schema
$mod
Melakukan operasi modulo 
$regex
Mengambil document sesuai dengan regular expression (PCRE)
$text
Melakukan pencarian menggunakan text
$where
Mengambil document dengan JavaScript Function

Kode Program
https://github.com/ProgrammerZamanNow/belajar-mongodb/blob/master/scripts/query-evaluation.js
// select * from products where price > 1000000
db.products.find({
    $expr: {
        $gt: ["$price", 1000000]
    }
});

// select * from customers where toUpper(_id) = 'KHANNEDY'
db.customers.find({
    $expr: {
        $eq: [
            { $toUpper: "$_id" }, 
            "KHANNEDY"
        ]
    }
});

// select * from products where name is not null and category is not null
db.products.find({
    $jsonSchema: {
        required: [ "name", "category"]
    }
});

// select * from products where name is not null and type(name) = 'string' and type(price) = 'long'
db.products.find({
    $jsonSchema: {
        required: [ "name"],
        properties: {
            name: {
                bsonType: "string"
            },
            price: {
                bsonType: "long"
            }
        }
    }
});

// select * from products where price % 5 = 0
db.products.find({ 
    price: { 
        $mod: [5, 0]
    } 
});

// select * from products where name like "%mie%"
db.products.find({
    name: {
        $regex: /mie/,
        $options: "i"
    }
});

// select * from products where name like "Mie%"
db.products.find({
    name: {
        $regex: /^Mie/
    }
});

// create text index on products
db.products.createIndex({
    name: "text"
});

// select * from products where (name like "%mie%" or name like "%sedap%")
db.products.find({
    $text: {
        $search: "mie sedap"
    }
});

// select * from products where name like "%mie sedap%"
db.products.find({
    $text: {
        $search: '"mie sedap"'
    }
});

// select * fro customers where _id = "khannedy"
db.customers.find({
    $where: function(){
        return this._id == "khannedy";
    }
});

--Array Query Operator
Array Operator
 Operator
Keterangan
$all
Mencocokkan array yang mengandung elemen-elemen tertentu
$elemMatch
Mengambil document jika tiap element di array memenuhi kondisi tertentu
$size
Mengambil document jika ukuran array sesuai 

Kode Program
https://github.com/ProgrammerZamanNow/belajar-mongodb/blob/master/scripts/query-array.js
//  insert some products  with tags
db.products.insertMany([
    {
        _id: 6,
        name: "Logitech M235 Wireless Mouse",
        price: new NumberLong(175000),
        category: "laptop",
        tags: [
            "logitech", "mouse", "accessories"
        ]
    },
    {
        _id: 7,
        name: "Havit Cooler Pad Gaming 5Fan Blue led F2082",
        price: new NumberLong(200000),
        category: "laptop",
        tags: [
            "cooler", "laptop", "accessories", "fan"
        ]
    },
    {
        _id: 8,
        name: "Samsung LC24F390FHEXXD Curved Monitor ",
        price: new NumberLong(1750000),
        category: "computer",
        tags: [
            "samsung", "monitor", "computer"
        ]
    }
]);

// select * from products where (tags = "samsung" and tags = "monitor")
db.products.find({
    tags: {
        $all: ["samsung", "monitor"]
    }
});

// select * from products where tags in ("samsung",  "logitect")
db.products.find({
    tags: {
        $elemMatch: {
            $in: ["samsung", "logitech"]
        }
    }
});

// select * from products where size(tags) = 3
db.products.find({
    tags: {
        $size: 3
    }
});

--Projection Operator
Projection
Pada function find, terdapat parameter kedua setelah query, yaitu projection
Projection adalah memilih field mana yang ingin kita ambil atau hide
db.<collection>.find(query, projection)

Projection Operator
 Operator
Keterangan
$
Limit array hanya mengembalikan data pertama yang match dengan array operator
$elemMatch
Limit array hanya mengembalikan data pertama yang match dengan kondisi query
$meta
Mengembalikan informasi metadata yang didapat dari setiap matching document
$slice
Mengontrol jumlah data yang ditampilkan pada array

Kode Program
https://github.com/ProgrammerZamanNow/belajar-mongodb/blob/master/scripts/query-projection.js
// select _id, name, category from products
db.products.find({}, {
    name: 1,
    category: 1
});

// select _id, name, category, price from products
db.products.find({}, {
    tags: 0
});


// select _id, name, category, price, tags[first] from products where tags in ("samsung", "logitech")
db.products.find({
    tags: {
        $elemMatch: {
            $in: ["samsung", "logitech"]
        }
    }
}, {
    name: 1,
    category: 1,
    price: 1,
    "tags.$": 1
});

// select _id, name, category, price, tags(in ("samsung", "logitech")) from products
db.products.find({}, {
    name: 1,
    category: 1,
    price: 1,
    tags: {
        $elemMatch: {
            $in: ["samsung", "logitech"]
        }
    }
})

// select *, score from products where $search like "monitor"
db.products.find({
    $text: {
        $search: "monitor"
    }
},{
    score: {
        $meta: "textScore"
    }
})

// select _id, name, price, category, tags[0,2] from products
db.products.find({}, {
    tags: {
        $slice: 2
    }
});

// select _id, name, price, category, tags[last 2] from products
db.products.find({}, {
    tags: {
        $slice: -2
    }
});

// select _id, name, price, category, tags[from, limit] from products
db.products.find({}, {
    tags: {
        $slice: [1, 1]
    }
});

--Query Modifier
Query Modifier
Query Modifier adalah memodifikasi hasil query yang telah kita lakukan
Contoh yang sering kita lakukan seperti, mengubah query menjadi jumlah data, membatasi jumlah data dengan paging, dan lain-lain
Untuk memodifikasi hasil query, kita bisa menambahkan function query modifier setelah menggunakan function find

Query Modifier Function
 Operator
Keterangan
count()
Mengambil jumlah data hasil query
limit(size)
Membatasi jumlah data yang didapat dari query
skip(size)
Menghiraukan data pertama hasil query sejumlah yang ditentukan
sort(query)
Mengurutkan hasil data query

Kode Program
// select count(*) from products
db.products.find({}).count()

// select * from products limit 4
db.products.find({}).limit(4)

// select * from products offset 2
db.products.find({}).skip(2)

// select * from products limit 4 offset 2
db.products.find({}).limit(4).skip(2)

// select * from products order by name asc, category desc
db.products.find({}).sort({
    name: 1,
    category: -1
})

--Update Document
Update Document
Sama seperti database lainnya, di MongoDB juga kita bisa mengubah document yang sudah kita insert ke collection
Namun berbeda dengan perintah SQL, di MongoDB, untuk mengubah document, kita diberikan beberapa function
Untuk update document, kita bisa menggunakan collection : db.<collection>.<updateFunction>()

Update Document Function
 Operator
Keterangan
updateOne()
Mengubah satu document
updateMany()
Mengubah banyak document sekaligus
replaceOne()
Mengubah total satu document dengan document baru

Kode Program
// update products set category = "food" where _id = 1
db.products.find({ _id: 1 });
db.products.updateOne(
  {
    _id: 1,
  },
  {
    $set: {
      category: 'food',
    },
  }
);

// update products set category = "food" where _id = 2
db.products.updateOne(
  {
    _id: 2,
  },
  {
    $set: {
      category: 'food',
    },
  }
);

// update products set tags = ["food"] where category = "food" and tags is null
db.products.updateMany(
  {
    $and: [
      {
        category: {
          $eq: 'food',
        },
      },
      {
        tags: {
          $exists: false,
        },
      },
    ],
  },
  {
    $set: {
      tags: ['food'],
    },
  }
);

// update products set wrong = "wrong"
db.products.updateMany({}, [
  {
    $set: {
      wrong: 'wrong',
    },
  },
]);

// update products set wrong = null
db.products.updateMany({}, [
  {
    $set: {
      wrong: null,
    },
  },
]);
db.products.updateMany({}, [
  {
    $unset: ['wrong'],
  },
]);

// insert wrong document
db.products.insertMany([
  {
    _id: 9,
    name: 'Ups Salah',
    wrong: 'Salah Lagi',
  },
]);

// replace document with id 9
db.products.replaceOne(
  {
    _id: 9,
  },
  {
    name: 'Adidas Pulseboost HD Running Shoes Sepatu lari Pria',
    price: new NumberLong(1100000),
    category: 'shoes',
    tags: ['adidas', 'shoes', 'running'],
  }
);

--Field Update Operator
Field Update Operator
Sebelumnya kita sudah tau kalo untuk update document di MongoDB kita bisa menggunakan operator $set dan $unset
Namun sebenarnya masih banyak operator yang bisa kita gunakan

Update Document Function
 Operator
Keterangan
$set
Mengubah nilai field di document
$unset
Menghapus field di document
$rename
Mengubah nama field di document
$inc
Menaikan nilai number di field sesuai dengan jumlah tertentu 
$currentDate
Mengubah field menjadi waktu saat ini

Kode Program
// alter table customers change name full_name
db.customers.updateMany({}, {
    $rename: {
        name: "full_name"
    }
})

// update products set stock = stock + 10
db.products.updateMany({}, {
    $inc: {
        stock: 10
    }
});

// update products set lastModifiedDate = current_date()
db.products.updateMany({}, {
    $currentDate: {
        lastModifiedDate: {
            $type: "date"
        }
    }
});

--Array Update Operator
Array Update Operator
Secara default, saat kita mengubah field dengan tipe array, maka seluruh array akan diubah
Kadang  kita ingin menambah, atau hanya mengubah data array tanpa harus mengubah seluruh field array
Hal ini bisa dilakukan di MongoDB

Array Update Operator (1)
 Operator
Keterangan
$
Mengupdate data array pertama sesuai kondisi query
$[]
Mengupdate semua data array sesuai kondisi query
$[<identifier>]
Mengupdate semua data array yang sesuai kondisi arrayFilters
<index>
Mengupdate data array sesuai dengan nomor index

Array Update Operator (2)
 Operator
Keterangan
$addToset
Menambahkan value ke array, dihiraukan jika sudah ada
$pop
Menghapus element pertama (-1) atau terakhir (1) array
$pull
Menghapus semua element di array yang sesuai kondisi
$push
Menambahkan element ke array
$pullAll
Menghapus semua element di array

Array Update Operator Modifier
 Operator
Keterangan
$each
Digunakan di $addToSet dan $push, untuk menambahkan multiple element
$position
Digunakan di $push untuk mengubah posisi menambahkan data
$slice
Digunakan di $push untuk menentukan jumlah maksimal data array
$sort
Digunakan untuk mengurutkan array setelah operasi $push

Kode Program
// update products set ratings = [90, 80, 70]
db.products.updateMany({}, {
    $set: {
        ratings: [90, 80, 70]
    }
});

// update first element of array, query must include array fields
db.products.updateMany({ 
    ratings: 90
}, {
    $set: {
        "ratings.$": 100
    }
});

// update all element of array
db.products.updateMany({}, {
    $set: {
        "ratings.$[]": 100
    }
})

// update products set ratings = [90, 80, 70]
db.products.updateMany({}, {
    $set: {
        ratings: [90, 80, 70]
    }
});

// update element of array based on arrayFilters
db.products.updateMany({}, {
    $set: {
        "ratings.$[element]" : 100
    }
},{
    arrayFilters: [ 
        { 
            element: { 
                $gte: 80
            } 
        } 
    ]
})

// update element of array with given index
db.products.updateMany({}, {
    $set: {
        "ratings.0": 50,
        "ratings.1": 60
    }
});

// add "popular" to array if not exists
db.products.updateOne({
    _id: 1
}, {
    $addToSet: {
        tags: "popular"
    }
});

// remove first element of array
db.products.updateMany({}, {
    $pop: {
        ratings: -1
    }
});

// update products set rating = [90, 80, 70]
db.products.updateMany({}, {
    $set: {
        ratings: [90, 80, 70]
    }
});

// remove all element where ratings >= 80
db.products.updateMany({}, {
    $pull: {
        ratings: {
            $gte: 80
        }
    }
})

// add 100 to ratings
db.products.updateMany({}, {
    $push: {
        ratings: 100
    }
})

// remove element 100 
db.products.updateMany({}, {
    $pullAll: {
        ratings: [100]
    }
})

// add 100, 200, 300 to ratings
db.products.updateMany({},{
    $push: {
        ratings: {
            $each: [100, 200, 300]
        }
    }
})

// add trending, popular to tags
db.products.updateMany({},{
    $addToSet: {
        tags: {
            $each: ["trending", "popular"]
        }
    }
})

// add hot in posititon 1
db.products.updateMany({},{
    $push: {
        tags: {
            $each: ["hot"],
            $position: 1
        }
    }
})

// add all element, but limit with slice
db.products.updateMany({},{
    $push: {
        ratings: {
            $each: [100, 200, 300, 400, 500],
            $slice: -5
        }
    }
})

// add all element, and sort desc
db.products.updateMany({},{
    $push: {
        ratings: {
            $each: [100, 200, 300, 400, 500],
            $sort: -1
        }
    }
})

--Delete Document
Delete Document
MongoDB memiliki function yang bisa kita gunakan untuk menghapus document di collection secara permanen
Document yang sudah kita hapus, tidak akan bisa dikembalikan lagi

Delete Document Function
 Function
Keterangan
db.<collection>.deleteOne(query)
Menghapus satu document yang sesuai dengan kondisi query
db.<collection>.deleteMany(query)
Menghapus banyak document yang sesuai dengan kondisi query

Kode Program
// Insert spammer document
db.customers.insertOne({
    _id: "spammer",
    full_name: "Spammer"
});

// Delete document by _id
db.customers.deleteOne({
    _id: "spammer"
});

// Insert many spammer documents
db.customers.insertMany([
    {
        _id: "spammer1",
        full_name: "Spammer1"
    },
    {
        _id: "spammer2",
        full_name: "Spammer2"
    },
    {
        _id: "spammer3",
        full_name: "Spammer3"
    }
]);

// Delete many documents
db.customers.deleteMany({
    _id: {
        $regex: "spammer"
    }
})

--Bulk Write Operations
Bulk Write Operation
Komunikasi antara aplikasi dengan database biasanya dilakukan secara request-response
Artinya tiap perintah yang ingin kita kirimkan dari aplikasi ke database, akan diresponse secara langsung oleh database
Proses tersebut akan sangat lambat, jika kita menghadapi kasus harus memanipulasi data besar secara langsung. Misal upload data dari file dengan jumlah jutaan ke dalam database.
MongoDB mendukung Bulk Write Operation, yaitu operasi bulk yang dalam satu request, kita bisa mengirim banyak perintah
Fitur ini cocok pada kasus jika kita ingin melakukan operasi bulk atau batch secara banyak sekaligus

Bulk Write Function
 Function
Keterangan
db.<collection>.insertMany()
Insert document secara banyak sekaligus
db.<collection>.updateMany()
Update document secara banyak sekaligus
db.<collection>.deleteMany()
Delete document secara banyak sekaligus
db.<collection>.bulkWrite()
Melakukan operasi write (insert, update, delete) banyak secara sekaligus

Supported Bulk Write Operation
insertOne
updateOne
updateMany
replaceOne
deleteOne
deleteMany

Kode Program
db.customers.bulkWrite([
    {
        insertOne: {
            document: {
                _id: "eko",
                full_name: "Eko"
            }
        }
    },
    {
        insertOne: {
            document: {
                _id: "kurniawan",
                full_name: "Kurniawan"
            }
        }
    },
    {
        updateMany: {
            filter: {
                _id: {
                    $in: ["eko", "kurniawan", "khannedy"]
                }
            },
            update: {
                $set: {
                    full_name: "Eko Kurniawan Khannedy"
                }
            }
        }
    }
])

--Schema Validation
Schema Validation
Pada Relational DB, kita biasanya menambahkan constraint terhadap data yang ada di tabel
Misal, maksimal karakter, Enum string, Not Null, dan lain-lain
Di MongoDB, fitur untuk validasi data lebih canggih dibanding constraint di Relational DB
MongoDB mendungkung Schema Validation menggunakan JSON Schema

JSON Schema
JSON Schema adalah standar resmi untuk memvalidasi data JSON
Dengan menggunakan JSON Schema, kita bisa memberi batasan, data JSON apa yang valid, sehingga bisa dimasukkan ke dalam collection
http://json-schema.org/ 

Kode Program
// Create category collection
db.createCollection('merchants', {
  validationAction: 'error',
  validator: {
    $jsonSchema: {
      bsonType: 'object',
      required: ['name', 'balance', 'type', 'address'],
      properties: {
        name: {
          bsonType: 'string',
          description: 'Must be a string',
        },
        balance: {
          bsonType: 'long',
          description: 'Must be a long',
        },
        type: {
          enum: ['PREMIUM', 'REGULAR'],
          description: 'Can only be one of enum values',
        },
        address: {
          bsonType: 'object',
          required: ['street', 'city'],
          properties: {
            street: {
              bsonType: 'string',
              description: 'Must be a string',
            },
            city: {
              bsonType: 'string',
              description: 'Must be a string',
            },
            country: {
              bsonType: 'string',
              description: 'Must be a string',
            },
          },
        },
      },
    },
  },
});

// Insert valid document
db.merchants.insertOne({
  _id: 'toko1',
  name: 'Toko Satu',
  balance: new NumberLong(1000000),
  type: 'PREMIUM',
  address: {
    street: 'Jalan Raya Belum Jadi',
    city: 'Jakarta',
    country: 'Indonesia',
  },
});

// Inser Invalid document: Name is blank
db.merchants.insertOne({
  _id: 'toko2',
  balance: new NumberLong(1000000),
  type: 'PREMIUM',
  address: {
    street: 'Jalan Raya Belum Jadi',
    city: 'Jakarta',
    country: 'Indonesia',
  },
});

// Inser Invalid document: Address City is blank
db.merchants.insertOne({
  _id: 'toko2',
  name: 'Toko Dua',
  balance: new NumberLong(1000000),
  type: 'PREMIUM',
  address: {
    street: 'Jalan Raya Belum Jadi',
    country: 'Indonesia',
  },
});

// Add validator to customers collection
db.runCommand({
  collMod: 'customers',
  validationAction: 'error',
  validator: {
    $jsonSchema: {
      bsonType: 'object',
      required: ['full_name'],
      properties: {
        full_name: {
          bsonType: 'string',
          description: 'Must be a string',
        },
      },
    },
  },
});

db.customers.insertOne({
  _id: 'salah',
  name: 'Salah',
});

--Indexes
Indexes
Index adalah fitur di MongoDB untuk mengefisienkan proses query. Tanpa Index, MongoDB harus melakukan proses query dengan cara collection scan (mencari keseluruh data dari awal sampai akhir)
Jika terdapat Index pada collection MongoDB, MongoDB bisa menggunakan Index untuk mendapatkan data, tanpa harus melakukan pencarian keseluruh document
Index adalah struktur data khusus yang menyimpan data dalam struktur yang mudah untuk dicari. 
Index menyimpan spesifik field, lalu mengurutkan data field tersebut. Hal ini tidak hanya mempermudah ketika proses pencarian, namun mempermudah ketika kita butuh melakukan pencarian dalam bentuk range document (seperti paging).
Secara dasar, Index di MongoDB, cara kerjanya sama seperti Index di Relational DB

Create Index Function
 Function
Keterangan
db.<collection>.createIndex()
Membuat index di collection
db.<collection>.getIndexes()
Melihat semua index di collection
db.<collection>.dropIndex()
Menghapus index di collection

Single Field Index
Secara default, field _id di MongoDB sudah di index secara otomatis, jadi kita tidak perlu membuat index lagi secara manual untuk field _id
MongoDB mendukung penuh pembuatan index di semua field yang ada di document. Dengan begitu, ini bisa mempercepat proses query di MongoDB untuk query terhadap field tersebut

Compound Indexes
Jika kita butuh melakukan query terhadap lebih dari satu field, kita juga bisa membuat index terhadap lebih dari satu field, atau disebut Compound Index
MongoDB membatasi pembuatan maksimal field yang bisa dibuat di compound index adalah 32 field

Kode Program
// Create index at category in products collection
db.products.createIndex({
    category: 1
});

// Get all indexes in products collection
db.products.getIndexes();

// Find products by category (will use index)
db.products.find({
    category: "food"
});

// Debugging query optimization
db.products.find({
    category: "food"
}).explain();
db.products.find({}).sort({
    category:1
}).explain();

// Create index at price and tags in products collection
db.products.createIndex({
    stock: 1,
    tags: 1
});

// Find products by stock and tags (will use index)
db.products.find({
    stock: 10,
    tags: "popular"
});

// Debugging query optimization
db.products.find({
    stock: 10
}).explain();
db.products.find({
    stock: 10,
    tags: "popular"
}).explain();
db.products.find({
    tags: "popular"
}).explain();

Indexing Strategy
Buat index untuk mendukung performa query
Gunakan single index, jika kita hanya melakukan query terhadap satu field saja
Gunakan compound index, jika kita sering melakukan query ke field pertama, atau kombinasi field pertama dan kedua, atau pertama dan kedua dan seterusnya
Buat index untuk mengurutkan hasil query
Sering-seringlah menggunakan function explain() untuk mengecek apakah query kita sudah di optimize dengan index atau belum

--Text Indexes
Text Indexes
MongoDB menyediakan text index untuk mendukung pencarian text di tipe data string.
Text index tidak hanya bisa digunakan pada field dengan tipe data string, namun juga pada array berisi tipe data string

Kode Program
// drop current index text
db.products.dropIndex("name_text");

// create index text
db.products.createIndex({
    name: "text",
    category: "text",
    tags: "text"
}, {
    weights: {
        name: 10,
        category: 5,
        tags: 1
    }
});

// search products with text "mie"
db.products.find({
    $text: {
        $search: "mie"
    }
});

// search products with text "mie" OR "laptop"
db.products.find({
    $text: {
        $search: "mie laptop"
    }
});

// search products with text "mie sedap"
db.products.find({
    $text: {
        $search: '"mie sedap"'
    }
});

// search products with text "mie" and NOT "sedap"
db.products.find({
    $text: {
        $search: "mie -sedap"
    }
});

// Debugging query optimization
db.products.find({
    $text: {
        $search: "mie -sedap"
    }
}).explain();

--Wildcard Indexes
Wildcard Indexes
MongoDB mendukung wildcard index, dimana ini digunakan untuk membuat index terhadap field yang belum diketahui atau field yang sering berubah-ubah
Misal contoh kita punya sebuah embedded document dengan tipe field customFields, dimana isi nya bisa bebas sesuai dengan data yang dimasukkan.
Agar bisa mendukung proses query yang cepat pada field tersebut, kita bisa menggunakan wildcard index

Kode Program
// membuat wildcard index
db.customers.createIndex({
    "customFields.$**" : 1
});

// Insert many customers
db.customers.insertMany([
    {
        _id: "budi",
        full_name: "Budi",
        customFields: {
            hobby: "Gaming",
            university: "Universitas Belum Ada"
        }
    },
    {
        _id: "joko",
        full_name: "Joko",
        customFields: {
            ipk: 3.2,
            university: "Universitas Belum Ada"
        }
    },
    {
        _id: "rudi",
        full_name: "Rudi",
        customFields: {
            motherName: "Tini",
            passion: "Entepreneur"
        }
    }
])

// Debug wildcard index
db.customers.find({
    "customFields.passion": "Enterpreneur"
}).explain();
db.customers.find({
    "customFields.ipk": 3.2
}).explain();
db.customers.find({
    "customFields.hobby": "Gaming"
}).explain();

--Index Properties
MongoDB mendukung properties di index
Istilah properties di Index mungkin agak sedikit membingungkan, sederhananya adalah menambahkan behaviour atau kemampuan tertentu terhadap index yang kita buat

TTL Index
TTL singkatan dari  Time To Live, yaitu waktu untuk hidup
TTL Index digunakan sebagai waktu hidup document di collection, artinya data akan hilang dalam kurun waktu tertentu secara otomatis
TTL Index hanya dapat digunakan di field dengan tipe data Date
Background proses di  MongoDB akan secara regular melakukan penghapusan data secara otomatis
Sayangnya, proses background tersebut berjalan setiap 60 detik sekali

Unique Index
Unique Index memastikan bahwa field-field di index tersebut tidak menyimpan data duplicate.
Contohnya, di MongoDB, field _id secara otomatis merupakan unique index, sehingga kita tidak bisa membuat document dengan field _id yang sama

Kode Program
// Create session collection
db.createCollection("sessions");

// Create TTL Index
db.sessions.createIndex({
    createdAt: 1
}, {
    expireAfterSeconds: 10
})

// Will expire after 10 seconds, but background job run every 60 seconds
db.sessions.insertOne({
    _id: 1,
    session: "Session 1",
    createdAt: new Date()
});

// Update all customers email
db.customers.updateMany({}, [
    {
        $set: {
            email: {
                "$concat": ["$_id", "@" , "example.com"]
            }
        }
    }
])

// Create unique index
db.customers.createIndex({
    email: 1
}, {
    unique: true
});

// failed duplicate email
db.customers.insertOne({
    _id: "gagal",
    full_name : "Gagal",
    email: "eko@example.com"
});

--Transactions
Transaction
Di Relational DB, fitur yang sangat berguna dan banyak orang gunakan adalah fitur transaction
Fitur transaction secara sederhana adalah menggabungkan kan beberapa operasi database dalam satu transaction, dimana transaction akan dianggap sukses jika semua operasi sukses, dan transaction akan dianggap gagal jika ada salah satu operasi yang gagal
Dan jika transaction gagal, maka seluruh operasi yang sukses sebelumnya harus dibatalkan (rollback)
Fitur transaction di MongoDB hanya bisa jalan di cluster (replica-set), tidak di single node
Dalam cluster, Database di MongoDB akan memiliki primary data dan secondary data

MongoDB Cluster Replica Set
http://www.plantuml.com/plantuml/uml/VOz12iCW44NtdcBm1act8GIoBkqLHAT1gauOTH5AxbxRZLBIk7F-__F-J34fJjax8LQbdsf1a5SA2y7iSap84buYa47uJhloW_8UrXNZdSbadM1OsNh5soYXKUUI9uyCGqHDmIYsq8soSTpOjF86VP5tqV3wOrvDr8KjiZOwnNM_kCj_N2ruVc5_XAnjzWzmmc2oTsy0

Transaction Function
 Function
Keterangan
session.startTransaction()
Memulai transaksi
session.commitTransaction()
Commit transaksi
session.abortTransaction()
Membatalkan transaksi

Read Preferences
Read preferences adalah bagaimana MongoDB mengkontrol dari mana kita membaca data
primary : Semua query diambil dari primary replica set
primaryPreferred : Semua query diambil dari  primary replica set, namun jika tidak ada primary replica set, maka diambil dari  secondary replica set
secondary: Semua query diambil dari secondary replica set
secondaryPreferred : Semua query diambil dari secondary replica set,  namun jika tidak ada secondary replica set, maka diambil dari primary replica set
nearest : Semua query diambil dari replica set paling murah network latency nya

Read Concern
Read Concern adalah bagaimana MongoDB mengkontrol data yang kita dapatkan
local: Data akan didapatkan di local node
available : Data akan didapatkan dimanapun (tidak peduli node mana)
majority : Data akan didapatkan di mayoritas data di semua node
linearizable : Data akan dipastikan data paling terbaru di semua node
snapshot : Data akan diambil dari mayoritas data snapshot (data yang telah di commit) di  semua node

Write Concern
Write Concern adalah bagaimana MongoDB mengkontrol operasi write (insert, update, delete)
<number> : Operasi dianggap sukses jika sudah berhasil melakukan operasi write di node sejumlah <number>
majority : Operasi dianggap sukses jika sudah berhasil melakukan operasi write di mayoritas node

Kode Program
//Make 3 mongo
//docker-compose -f docker-compose.yml up -d
//docker container exec -it mongo1 /bin/sh

// Setting replication
rs.initiate({
  _id: 'my-mongo-set',
  members: [
    { _id: 0, host: 'mongo1:27017' },
    { _id: 1, host: 'mongo2:27017' },
    { _id: 2, host: 'mongo3:27017' },
  ],
});

// Create collection
db.createCollection('products');
db.createCollection('orders');

// Insert products
db.products.insertMany([
  {
    _id: 1,
    name: 'Indomie Ayam Bawang',
    price: new NumberLong(2000),
    quantity: 10,
  },
  {
    _id: 2,
    name: 'Mie Sedap',
    price: new NumberLong(2000),
    quantity: 10,
  },
]);

// Sample abort transaction
var session = db.getMongo().startSession({ readPreference: { mode: 'primary' } });
session.startTransaction({ readConcern: { level: 'majority' }, writeConcern: { w: 'majority' } });
session.getDatabase('test').orders.insertOne({
  _id: new ObjectId(),
  total: new NumberLong(8000),
  items: [
    {
      product_id: 1,
      price: new NumberLong(2000),
      quantity: new NumberInt(2),
    },
    {
      product_id: 2,
      price: new NumberLong(2000),
      quantity: new NumberInt(2),
    },
  ],
});
session.getDatabase('test').products.updateOne(
  {
    _id: 1,
  },
  {
    $inc: {
      quantity: -2,
    },
  }
);
session.getDatabase('test').products.updateOne(
  {
    _id: 2,
  },
  {
    $inc: {
      quantity: -2,
    },
  }
);
session.abortTransaction();
session.endSession();

// Sample commit transaction
var session = db.getMongo().startSession({ readPreference: { mode: 'primary' } });
session.startTransaction({ readConcern: { level: 'majority' }, writeConcern: { w: 'majority' } });
session.getDatabase('test').orders.insertOne({
  _id: new ObjectId(),
  total: new NumberLong(8000),
  items: [
    {
      product_id: 1,
      price: new NumberLong(2000),
      quantity: new NumberInt(2),
    },
    {
      product_id: 2,
      price: new NumberLong(2000),
      quantity: new NumberInt(2),
    },
  ],
});
session.getDatabase('test').products.updateOne(
  {
    _id: 1,
  },
  {
    $inc: {
      quantity: -2,
    },
  }
);
session.getDatabase('test').products.updateOne(
  {
    _id: 2,
  },
  {
    $inc: {
      quantity: -2,
    },
  }
);
session.commitTransaction();
session.endSession();

--Security
Security
Secara default, jika kita menjalankan MongoDB, mode yang dijalankan tidaklah aman
Tidak ada Authentication dan tidak ada Authorization
Agar aman, kita harus mengaktifkan fitur access control di MongoDB

User Admin
User admin harus ada terlebih dahulu sebelum kita mengaktifkan access control
User admin adalah user yang memiliki role userAdminAnyDatabase dan readWriteAnyDatabase
Setelah membuat user admin, kita bisa menjalankan ulang MongoDB dengan perintah --auth

Kode Program
// use admin database
// use admin

db.createUser(
    {
        user: "mongo",
        pwd: "mongo",
        roles: [ 
            "userAdminAnyDatabase",
            "readWriteAnyDatabase" 
        ]
    }
)

// Connect to mongodb with username & password
// mongo --username mongo --password mongo --host localhost --port 27017

--Authentication
Authentication
Authentication adalah proses memverifikasi identitas pengguna ketika mengakses MongoDB
Saat menggunakan authentication, maka client wajib menggunakan username dan password untuk terkoneksi ke MongoDB server
MongoDB mendukung banyak mekanisme authentication, seperti :
SCRAM : https://tools.ietf.org/html/rfc5802
Certificate Authentication
LDAP
Kerberos, dan lain-lain

User
Di MongoDB, kita bisa menambahkan user, dan juga menambahkan role ke user tersebut
Saat kita membuat user, kita harus menentukan database sebagai authentication database
Namun bukan berarti user hanya bisa mengakses database itu saya, tapi user juga bisa mengakses database lain jika mau
Nama user harus unik per database, namun jika database nya berbeda, kita bisa membuat user dengan nama yang sama

User Function
 Function
Keterangan
db.createUser()
Membuat user
db.getUsers()
Mendapatkan semua user
db.dropUser()
Menghapus user
db.updateUser()
Mengupdate user
db.changeUserPassword()
Mengubah user password

Kode Program
// Use test database as authentication databae
// use test;

// Create user with access read only
db.createUser(
    {
        user: "contoh",
        pwd: "contoh", 
        roles: [
            { role: "read", db: "test" }
        ]
    }
)

// connect using
// mongo --username contoh --password contoh --authenticationDatabase test

// Create user with access read
db.createUser(
    {
        user: "contoh2",
        pwd: "contoh2", 
        roles: [
            { role: "readWrite", db: "test" }
        ]
    }
)

// connect using
// mongo --username contoh2 --password contoh2 --authenticationDatabase test

// Get all users
db.getUsers()

// Change password for user contoh
db.changeUserPassword("contoh", "rahasia")

// Drop user contoh
db.dropUser("contoh")

// Update user
db.updateUser("contoh2",
    {
        roles: [
            { role: "readWrite", db: "test" }
        ]
    }
)

--Authorization
Authorization
Authorization adalah proses yang dilakukan setelah proses Authentication sukses
Authorization dilakukan untuk melakukan pengecekan apakah user memiliki hak akses untuk melakukan sebuah action
Hak akses di MongoDB disimpan dalam bentuk role

Database Roles
 Role
Keterangan
read
Bisa membaca data di semua collection yang bukan sistem collection
readWrite
Bisa membaca dan mengubah data di semua collection yang bukan sistem collection
dbAdmin
Bisa melakukan kemampuan administrasi database
userAdmin
Mampu membuat user dan role
dbOwner
Kombinasi readWrite, dbAdmin dan userAdmin

All Database Roles
 Role
Keterangan
readAnyDatabase
Seperti read role, tapi untuk semua database
readWriteAnyDatabase
Seperti readWrite role, tapi untuk semua database
userAdminAnyDatabase
Seperti userAdmin, tapi untuk semua database
dbAdminAnyDatabase
Seperti dbAdmin, tapi untuk semua database

Backup & Restore Roles
 Role
Keterangan
backup
Kemampuan untuk melakukan backup database
restore
Kemampuan untuk melakukan restore database

Superuser Roles
 Role
Keterangan
root
Bisa melakukan apapun

Privileges
Role membatasi hak akses di level database
Kadang kita ingin membatasi di level collection
Untuk melakukan itu, kita bisa menggunakan privileges

Role Function
 Role
Keterangan
db.createRole()
Membuat role baru
db.getRoles()
Mendapatkan role
db.deleteRole()
Menghapus role
db.updateRole()
Mengubah role

Kode Program
// Use test database
// use test;

// create role
db.createRole({
    role: "find_and_insert",
    privileges: [],
    roles: [
        {
            role: "read",
            db: "test"
        }
    ]
});

// Get all roles
db.getRoles({ showPrivileges: true });

// update role
db.updateRole("find_and_insert", {
    privileges: [
        {
            resource: {
                db: "test",
                collection: "products"
            },
            actions: [ "insert" ]
        }
    ],
    roles: [
        {
            role: "read",
            db: "test"
        }
    ]
});

// Add use with role
db.createUser({
    user: "eko",
    pwd: "eko", 
    roles: [ "find_and_insert" ]
});

// Connect to mongo server
// mongo --username eko --password eko --authenticationDatabase test

// Insert product [SUCCESS]
db.products.insert({
    "_id" : 10,
    "name" : "iPad Pro 11 2020",
    "price" : NumberLong(20000000),
    "category" : "tablet",
    "tags" : [
        "apple",
        "ipad",
        "tablet",
    ],
    "lastModifiedDate" : new Date(),
    "stock" : 10,
    "ratings" : [
        100
    ]
});

// Delete product [FAILED]
db.products.deleteOne({
    _id: 10
});

// Update product [FAILED]
db.products.updateOne({
    _id: 10
},{
    $set: {
        category: "food"
    }
});

// Insert Customer [FAILED]
db.customers.insertOne({
    _id: "kurniawan",
    name: "Eko Kurniawan Khannedy"
});